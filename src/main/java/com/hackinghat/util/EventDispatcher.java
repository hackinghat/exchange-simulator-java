package com.hackinghat.util;

import com.hackinghat.util.component.AbstractComponent;
import com.hackinghat.util.mbean.MBeanAttribute;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.*;
import java.util.concurrent.Callable;
import java.util.concurrent.ScheduledFuture;

/**
 * Responsible for publication of an {@link Event}. This is centralised and delegated away to prevent both
 * individual objects needing to be observed and to centralise the machinery of managing the dispatched events
 * <p>
 * The event dispatcher also provides delegated access to its scheduled executor service.  This allows events
 */
public abstract class EventDispatcher extends AbstractComponent {
    private static final Logger LOG = LogManager.getLogger(EventDispatcher.class);

    private final Map<Class<? extends Event>, List<Listener>> observerMap;
    private int eventsDispatched = 0;

    EventDispatcher(final String name) {
        super(name);
        observerMap = new HashMap<>();
    }

    @MBeanAttribute(description = "Events dispatched")
    public int getEventsDispatched() {
        return eventsDispatched;
    }

    /**
     * Should be called by dispatchers after completion of dispatch
     */
    void eventDispatched() {
        eventsDispatched++;
    }

    /**
     * Publish an event to observers synchronously.  The purpose of the {@link EventDispatcher} is to
     * hide the handling of asynchronous event notifications {@link Event}.
     *
     * @param eventCopy a copy of the actual event, it should be the implementor's responsibility to pass this
     * @param <T>       the type of the event
     */
    <T extends Event> void dispatchSync(final T eventCopy) {
        notifyObservers(eventCopy);
    }

    /**
     * Publish the event according to the implementation
     *
     * @param event the original event as generated by observation point
     * @param <T>   the type of the observable (usually inferred)
     */
    abstract public <T extends Event> void dispatch(final T event);

    /**
     * Publish the event according to the implementation, the event will be published by calling dispatch
     * using the {@link EventDispatcher#schedule(Callable, long)}  method
     *
     * @param event       the original event as generated by observation point
     * @param <T>         the type of the observable (usually inferred)
     * @param nanosToWait the amount of milli-seconds to wait
     */
    public <T extends Event> ScheduledFuture<?> delayedDispatch(final T event, final long nanosToWait) {
        return schedule(() -> dispatch(event), nanosToWait);
    }

    /**
     * Exposes the scheduler used by the dispatcher (either sync or async) to allow other
     * clients to use it
     *
     * @param callable    the callable to execute
     * @param nanosToWait the number of milli-seconds to wait before executing it
     */
    abstract public ScheduledFuture<?> schedule(final Callable<?> callable, final long nanosToWait);

    public ScheduledFuture<?> schedule(final Runnable runnable, final long nanosToWait) {
        return schedule((Callable<Void>) () -> {
            runnable.run();
            return null;
        }, nanosToWait);
    }

    private void addEventTypes(Collection<Class<? extends Event>> eventTypes) {
        for (final Class<? extends Event> eventType : eventTypes) {
            if (!observerMap.containsKey(eventType)) {
                observerMap.put(eventType, Collections.synchronizedList(new ArrayList<>()));
            }
        }
    }

    /**
     * Return a list of the current observers, this method should be an unmodifiable copy of the real underlying observer
     * set, note that ideally this should be backed by a collection supporting concurrency.
     *
     * @return a set of the currently active observers
     */
    protected Map<Class<? extends Event>, List<Listener>> getObservers() {
        return Collections.unmodifiableMap(observerMap);
    }

    public void addListener(final Class<? extends Event> observedType, final Listener listener) {
        List<Listener> listeners = observerMap.get(observedType);
        if (listeners == null) {
            addEventTypes(Collections.singleton(observedType));
            listeners = observerMap.get(observedType);
        }
        if (listeners.contains(listener))
            throw new IllegalArgumentException("Listener already present: " + listener);
        listeners.add(listener);
    }

    public <T extends Event> boolean removeListener(final Class<T> observedType, final Listener listener) {
        final List<Listener> listeners = observerMap.get(observedType);
        if (listeners == null)
            throw new IllegalArgumentException("Observed type is not currently observed by this object: " + observedType);
        if (!listeners.contains(listener))
            throw new IllegalArgumentException("Listener not present for removal: " + listener);
        return listeners.remove(listener);
    }

    protected <T extends Event> void notifyObservers(final T observed) {
        final List<Listener> listeners = observerMap.get(observed.getClass());
        if (listeners != null) {
            for (final Listener listener : listeners) {
                try {
                    if (listener.shouldNotify(observed))
                        listener.notify(observed);
                } catch (Throwable t) {
                    LOG.error("A badly behaved listener: " + listener + " threw an exception whilst we were attempting to notify", t);
                }
            }
        }
    }
}
